// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync_state.sql

package store

import (
	"context"
	"time"
)

const deleteSyncStateByOwner = `-- name: DeleteSyncStateByOwner :exec
DELETE FROM sync_state WHERE owner_type = ? AND owner_id = ?
`

type DeleteSyncStateByOwnerParams struct {
	OwnerType string
	OwnerID   int64
}

func (q *Queries) DeleteSyncStateByOwner(ctx context.Context, arg DeleteSyncStateByOwnerParams) error {
	_, err := q.db.ExecContext(ctx, deleteSyncStateByOwner, arg.OwnerType, arg.OwnerID)
	return err
}

const getSyncState = `-- name: GetSyncState :one

SELECT owner_type, owner_id, endpoint, last_sync, cache_until
FROM sync_state
WHERE owner_type = ? AND owner_id = ? AND endpoint = ?
`

type GetSyncStateParams struct {
	OwnerType string
	OwnerID   int64
	Endpoint  string
}

// sqlc queries for the sync_state table.
// See https://docs.sqlc.dev for query annotation syntax.
func (q *Queries) GetSyncState(ctx context.Context, arg GetSyncStateParams) (SyncState, error) {
	row := q.db.QueryRowContext(ctx, getSyncState, arg.OwnerType, arg.OwnerID, arg.Endpoint)
	var i SyncState
	err := row.Scan(
		&i.OwnerType,
		&i.OwnerID,
		&i.Endpoint,
		&i.LastSync,
		&i.CacheUntil,
	)
	return i, err
}

const listSyncStatus = `-- name: ListSyncStatus :many
SELECT
    ss.owner_type,
    ss.owner_id,
    COALESCE(c.name, corp.name, '') AS owner_name,
    ss.endpoint,
    ss.last_sync,
    ss.cache_until
FROM sync_state ss
LEFT JOIN characters c ON ss.owner_type = 'character' AND c.id = ss.owner_id
LEFT JOIN corporations corp ON ss.owner_type = 'corporation' AND corp.id = ss.owner_id
ORDER BY ss.owner_type, ss.owner_id, ss.endpoint
`

type ListSyncStatusRow struct {
	OwnerType  string
	OwnerID    int64
	OwnerName  string
	Endpoint   string
	LastSync   time.Time
	CacheUntil time.Time
}

func (q *Queries) ListSyncStatus(ctx context.Context) ([]ListSyncStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listSyncStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSyncStatusRow
	for rows.Next() {
		var i ListSyncStatusRow
		if err := rows.Scan(
			&i.OwnerType,
			&i.OwnerID,
			&i.OwnerName,
			&i.Endpoint,
			&i.LastSync,
			&i.CacheUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSyncState = `-- name: UpsertSyncState :exec
INSERT INTO sync_state (owner_type, owner_id, endpoint, last_sync, cache_until)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(owner_type, owner_id, endpoint) DO UPDATE SET
    last_sync   = excluded.last_sync,
    cache_until = excluded.cache_until
`

type UpsertSyncStateParams struct {
	OwnerType  string
	OwnerID    int64
	Endpoint   string
	LastSync   time.Time
	CacheUntil time.Time
}

func (q *Queries) UpsertSyncState(ctx context.Context, arg UpsertSyncStateParams) error {
	_, err := q.db.ExecContext(ctx, upsertSyncState,
		arg.OwnerType,
		arg.OwnerID,
		arg.Endpoint,
		arg.LastSync,
		arg.CacheUntil,
	)
	return err
}
