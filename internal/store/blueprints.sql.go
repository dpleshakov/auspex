// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: blueprints.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const deleteBlueprintsByOwner = `-- name: DeleteBlueprintsByOwner :exec
DELETE FROM blueprints WHERE owner_type = ? AND owner_id = ?
`

type DeleteBlueprintsByOwnerParams struct {
	OwnerType string
	OwnerID   int64
}

func (q *Queries) DeleteBlueprintsByOwner(ctx context.Context, arg DeleteBlueprintsByOwnerParams) error {
	_, err := q.db.ExecContext(ctx, deleteBlueprintsByOwner, arg.OwnerType, arg.OwnerID)
	return err
}

const listBlueprintTypeIDsByOwner = `-- name: ListBlueprintTypeIDsByOwner :many
SELECT DISTINCT type_id
FROM blueprints
WHERE owner_type = ? AND owner_id = ?
`

type ListBlueprintTypeIDsByOwnerParams struct {
	OwnerType string
	OwnerID   int64
}

func (q *Queries) ListBlueprintTypeIDsByOwner(ctx context.Context, arg ListBlueprintTypeIDsByOwnerParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listBlueprintTypeIDsByOwner, arg.OwnerType, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var type_id int64
		if err := rows.Scan(&type_id); err != nil {
			return nil, err
		}
		items = append(items, type_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlueprints = `-- name: ListBlueprints :many
SELECT
    b.id,
    b.owner_type,
    b.owner_id,
    COALESCE(c.name, corp.name, '') AS owner_name,
    b.type_id,
    t.name AS type_name,
    t.group_id,
    g.name AS group_name,
    g.category_id,
    cat.name AS category_name,
    b.location_id,
    b.me_level,
    b.te_level,
    b.updated_at,
    j.id           AS job_id,
    j.activity     AS job_activity,
    j.status       AS job_status,
    j.start_date   AS job_start_date,
    j.end_date     AS job_end_date,
    j.installer_id AS job_installer_id,
    ic.name        AS job_installer_name
FROM blueprints b
JOIN eve_types t ON t.id = b.type_id
JOIN eve_groups g ON g.id = t.group_id
JOIN eve_categories cat ON cat.id = g.category_id
LEFT JOIN jobs j ON j.blueprint_id = b.id
LEFT JOIN characters c ON b.owner_type = 'character' AND c.id = b.owner_id
LEFT JOIN corporations corp ON b.owner_type = 'corporation' AND corp.id = b.owner_id
LEFT JOIN characters ic ON ic.id = j.installer_id
WHERE
    (?1 IS NULL OR b.owner_type = ?1)
    AND (?2 IS NULL OR b.owner_id = ?2)
    AND (?3 IS NULL OR g.category_id = ?3)
    AND (
        ?4 IS NULL
        OR (?4 = 'idle' AND j.id IS NULL)
        OR (?4 = 'active' AND j.status = 'active')
        OR (?4 = 'ready' AND j.status = 'ready')
    )
ORDER BY b.id
`

type ListBlueprintsParams struct {
	OwnerType  interface{}
	OwnerID    interface{}
	CategoryID interface{}
	Status     interface{}
}

type ListBlueprintsRow struct {
	ID               int64
	OwnerType        string
	OwnerID          int64
	OwnerName        string
	TypeID           int64
	TypeName         string
	GroupID          int64
	GroupName        string
	CategoryID       int64
	CategoryName     string
	LocationID       int64
	MeLevel          int64
	TeLevel          int64
	UpdatedAt        time.Time
	JobID            sql.NullInt64
	JobActivity      sql.NullString
	JobStatus        sql.NullString
	JobStartDate     sql.NullTime
	JobEndDate       sql.NullTime
	JobInstallerID   sql.NullInt64
	JobInstallerName sql.NullString
}

func (q *Queries) ListBlueprints(ctx context.Context, arg ListBlueprintsParams) ([]ListBlueprintsRow, error) {
	rows, err := q.db.QueryContext(ctx, listBlueprints,
		arg.OwnerType,
		arg.OwnerID,
		arg.CategoryID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBlueprintsRow
	for rows.Next() {
		var i ListBlueprintsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerType,
			&i.OwnerID,
			&i.OwnerName,
			&i.TypeID,
			&i.TypeName,
			&i.GroupID,
			&i.GroupName,
			&i.CategoryID,
			&i.CategoryName,
			&i.LocationID,
			&i.MeLevel,
			&i.TeLevel,
			&i.UpdatedAt,
			&i.JobID,
			&i.JobActivity,
			&i.JobStatus,
			&i.JobStartDate,
			&i.JobEndDate,
			&i.JobInstallerID,
			&i.JobInstallerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBlueprint = `-- name: UpsertBlueprint :exec

INSERT INTO blueprints (id, owner_type, owner_id, type_id, location_id, me_level, te_level, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    owner_type  = excluded.owner_type,
    owner_id    = excluded.owner_id,
    type_id     = excluded.type_id,
    location_id = excluded.location_id,
    me_level    = excluded.me_level,
    te_level    = excluded.te_level,
    updated_at  = excluded.updated_at
`

type UpsertBlueprintParams struct {
	ID         int64
	OwnerType  string
	OwnerID    int64
	TypeID     int64
	LocationID int64
	MeLevel    int64
	TeLevel    int64
	UpdatedAt  time.Time
}

// sqlc queries for the blueprints table.
// See https://docs.sqlc.dev for query annotation syntax.
func (q *Queries) UpsertBlueprint(ctx context.Context, arg UpsertBlueprintParams) error {
	_, err := q.db.ExecContext(ctx, upsertBlueprint,
		arg.ID,
		arg.OwnerType,
		arg.OwnerID,
		arg.TypeID,
		arg.LocationID,
		arg.MeLevel,
		arg.TeLevel,
		arg.UpdatedAt,
	)
	return err
}
