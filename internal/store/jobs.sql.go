// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package store

import (
	"context"
	"time"
)

const countCompletingToday = `-- name: CountCompletingToday :one
SELECT COUNT(*) FROM jobs
WHERE status = 'active' AND date(end_date) = date('now')
`

func (q *Queries) CountCompletingToday(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCompletingToday)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIdleBlueprints = `-- name: CountIdleBlueprints :one
SELECT COUNT(*) FROM blueprints b
WHERE NOT EXISTS (
    SELECT 1 FROM jobs j WHERE j.blueprint_id = b.id
)
`

func (q *Queries) CountIdleBlueprints(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countIdleBlueprints)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOverdueJobs = `-- name: CountOverdueJobs :one
SELECT COUNT(*) FROM jobs
WHERE status = 'ready' AND end_date < datetime('now')
`

func (q *Queries) CountOverdueJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOverdueJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteJobByID = `-- name: DeleteJobByID :exec
DELETE FROM jobs WHERE id = ?
`

func (q *Queries) DeleteJobByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteJobByID, id)
	return err
}

const deleteJobsByOwner = `-- name: DeleteJobsByOwner :exec
DELETE FROM jobs WHERE owner_type = ? AND owner_id = ?
`

type DeleteJobsByOwnerParams struct {
	OwnerType string
	OwnerID   int64
}

func (q *Queries) DeleteJobsByOwner(ctx context.Context, arg DeleteJobsByOwnerParams) error {
	_, err := q.db.ExecContext(ctx, deleteJobsByOwner, arg.OwnerType, arg.OwnerID)
	return err
}

const listCharacterSlotUsage = `-- name: ListCharacterSlotUsage :many
SELECT
    c.id,
    c.name,
    COUNT(j.id) AS used_slots
FROM characters c
LEFT JOIN jobs j ON j.installer_id = c.id
GROUP BY c.id, c.name
ORDER BY c.name
`

type ListCharacterSlotUsageRow struct {
	ID        int64
	Name      string
	UsedSlots int64
}

func (q *Queries) ListCharacterSlotUsage(ctx context.Context) ([]ListCharacterSlotUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacterSlotUsage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharacterSlotUsageRow
	for rows.Next() {
		var i ListCharacterSlotUsageRow
		if err := rows.Scan(&i.ID, &i.Name, &i.UsedSlots); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobIDsByOwner = `-- name: ListJobIDsByOwner :many
SELECT id FROM jobs WHERE owner_type = ? AND owner_id = ?
`

type ListJobIDsByOwnerParams struct {
	OwnerType string
	OwnerID   int64
}

func (q *Queries) ListJobIDsByOwner(ctx context.Context, arg ListJobIDsByOwnerParams) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listJobIDsByOwner, arg.OwnerType, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertJob = `-- name: UpsertJob :exec

INSERT INTO jobs (id, blueprint_id, owner_type, owner_id, installer_id, activity, status, start_date, end_date, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    blueprint_id = excluded.blueprint_id,
    owner_type   = excluded.owner_type,
    owner_id     = excluded.owner_id,
    installer_id = excluded.installer_id,
    activity     = excluded.activity,
    status       = excluded.status,
    start_date   = excluded.start_date,
    end_date     = excluded.end_date,
    updated_at   = excluded.updated_at
`

type UpsertJobParams struct {
	ID          int64
	BlueprintID int64
	OwnerType   string
	OwnerID     int64
	InstallerID int64
	Activity    string
	Status      string
	StartDate   time.Time
	EndDate     time.Time
	UpdatedAt   time.Time
}

// sqlc queries for the jobs table.
// See https://docs.sqlc.dev for query annotation syntax.
func (q *Queries) UpsertJob(ctx context.Context, arg UpsertJobParams) error {
	_, err := q.db.ExecContext(ctx, upsertJob,
		arg.ID,
		arg.BlueprintID,
		arg.OwnerType,
		arg.OwnerID,
		arg.InstallerID,
		arg.Activity,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.UpdatedAt,
	)
	return err
}
